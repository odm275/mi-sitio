---
title: Mise - Case Study (A FullStack Project)
date: '2022-08-19'
tags: ['Next.js', 'tRPC', 'prisma', 'postgreSQL']
draft: false
summary: Case Study of the Mise Project
---

# The Challenge:

Candelaris and its businesses have a vital mission: To deliver the authentic Italian experience to people in Houston.
An efficient management of their inventory and orders
needs to occur in order for them to be able to accomplish that.
Candelaris and its businesses needed a comprehensive technology program to improve their inventory management, employee trainning, communication between
managers and kitchens, and orders between the kitchen commisary and its locations.
As an expanding businesses, critical improvements were identified to be able to accommodate growing pains.

## Deciding my Tech Stack

I treated the development of Mise like a startup. I wanted be fast, nimble, efficient, and reliable. Thus, my tech stack choice set to fit those qualities.

### Database

When deciding a database I had the following considerations:

1.  SQL or NoSQL

    - Given that the App was going to be heavily relational in nature. The natural choice was SQL.
    - Unless there is a very specific need for a NoSQL database, a relational database will generally lead to less suffering.
    - Prisma db push allows me to skip migrations if I really want to. Thus, I can be nimble like with noSQL but keep retain the type stricness and relational benefits from SQL databases bring.

2.  Choose a Cloud Provider (Heroku, Railway, Render, Planetscale).

    - I considered planetscale(mysql) due to their superb version control database management features, however,
      given the scale of the project, I felt it was overkill. If the project had an unlimited budget, I would have gone with planetscale.

    - Railway was the easiests to set up and their payment costs were right. I spun up a Postgres staging and production instance in less than 5 minutes ðŸ˜³

Thus, I went with a PostgreSQL instance on Railway.
Now that I had my database requirements set, I went on to design the Database schema for the application:

The Database Fluid Charts
![Mise Database Schema](/static/images/projects/mise/mise_db_schema.png)

### Backend

For the backend I was mainly looking for **a safe** way to call my backend from my frontend. REST, GraphQL, and tRPC were all great candidates, however, tRPC
was the the best for this project. Here are some of the trade offs I considered:

##### GraphQL

- Pros:
  - Creates a type safe way to call my backend from the frontend (Ex: GraphQL Code Generator).
  - Useful for stablishing a contract between the Frontend and the Backend.
  - Suited for a public facing API.
  - Solves overfetching in the front end.
  - Can use multiple programing languages.
- Cons:
  - Its mental model takes more work to plan.
  - Relies on Code Generation to safely call backend from the frontend.

##### REST

- Pros:
  - Creates a type safe way to call my backend from my frontend (Ex: Swagger)
  - Can use multiple programing languages.
  - Suited for a public facing API.
  - Easier mental model than GraphQL. I just create end points as I need them.
- Cons:
  - Relies on Code Generation to safely call backend from the frontend.

##### tRPC

- Pros:
  - Creates a type safe way to call my backend from my frontend.
  - Automatic typescript connection between the front end and the backend. For example, if I make a change in the
    backend, typescript intellisense will document it live on VSCode.
  - Intellisense auto documentation. Hence, I open up some curly braces and I get a list of the apis available in my backend.
  - Easiest mental model. I just create end points as I need them, and they are intellisensed automatically.
- Cons:
  - Has to be a monorepo.
  - Tight coupling of frontend and backend.
  - Backend has to be written in typescript.
  - Best suited for internal services.

Overall, trpc had the best trade offs for this application. The cons were all negible for my case, and I got to reap all the pros. Alas,
I have a safe way to call my backend from my frontend, and I get top tier automatic intellisense. Thus, fast, nimble, efficient, and reliable
qualities I'm looking are maintained.

#### Next.js vs Custom Backend

Given that tRPC made the most sense for me, I embraced the coupling of frontend and backend, and went with Next.js API routes as the backend.
It worked amazing. I got a fullstack monorepo out the box, with typescript support and minimal set up.

#### Auth0

In the spirit of focusing my time in actually building the application, being fast and nimble, I went with Auth0. I had everything having to do with
authentication set up in less than hour. And most of the features around auth0 were well documentated and easy to grasps.
Hence, going with Auth0 was an excellent choice for my application.

I considered NextAuth.js, however for this application having a clasic credentials(email and password) authentication was important,
and this authentication method is explicily marked as limited in functionality with Next.js Auth.
Hence, I refrained from NextAuth.js

### Frontend

For this App I had the freedom to either render it on the client or the backend since the app was all behind a credentials log in.
I opted to client render most of the app in order to have it feel snappy and interactive to the user, and I used React Query to manage the server state.

React Query is an amazing library to handle server state. By default, I opted to invalidate queries whenever data was updated, and I used optimisitic queries
for parts of the app I wanted to feel fluid and snappy.

I used React Hook Form for most of the forms. As Forms get large, and complex, it is often hard to manage re-renders. Hence, I let react-hook-form manage
complex forms.

For the styling, I considered between Chackra UI and Tailwindcss.

For the checkout form
